<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <!-- Font Awesome -->
    <!--    <link rel="stylesheet" href="font-awesome-4.3.0/css/font-awesome.min.css"/> -->
    <script src="https://use.fontawesome.com/3dce4d8e65.js"></script>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <title>tangram: /home/portage/tangram/tangram/utility/get_material_moments.h Source File</title>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="doxy-boot.js"></script>
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand">tangram </a>
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_043c38e9c2239d2104f02eee845ed8d8.html">tangram</a></li><li class="navelem"><a class="el" href="dir_8c062d6981e3de3ea58d7a81e2ec1253.html">utility</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">get_material_moments.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="get__material__moments_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> This file is part of the Ristra tangram project.</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> Please see the license file at the root of this repository, or at:</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> https://github.com/laristra/tangram/blob/master/LICENSE</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">*/</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="preprocessor">#ifndef GET_MATERIAL_MOMENTS_H_</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="preprocessor">#define GET_MATERIAL_MOMENTS_H_</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="tangram_8h.html">tangram/support/tangram.h</a>&quot;</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="split__r2d_8h.html">tangram/intersect/split_r2d.h</a>&quot;</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="split__r3d_8h.html">tangram/intersect/split_r3d.h</a>&quot;</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh_Wrapper&gt;</div><div class="line"><a name="l00040"></a><span class="lineno"><a class="line" href="get__material__moments_8h.html#ac0c93b6da04bc9fa07409f5af57631ae">   40</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="get__material__moments_8h.html#ac0c93b6da04bc9fa07409f5af57631ae">get_material_moments</a>(<span class="keyword">const</span> Mesh_Wrapper&amp; mesh,</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;                          <span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="structTangram_1_1Plane__t.html">Tangram::Plane_t&lt;3&gt;</a> &gt;&amp; planar_interfaces,</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;                          <span class="keyword">const</span> std::vector&lt;int&gt;&amp; material_IDs,</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;                          std::vector&lt;int&gt;&amp; cell_num_mats,</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;                          std::vector&lt;int&gt;&amp; cell_mat_ids,</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                          std::vector&lt;double&gt;&amp; cell_mat_volfracs,</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;3&gt;</a> &gt;&amp; cell_mat_centroids,</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; std::vector&lt;r3d_poly&gt; &gt; &gt;&amp;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;                            reference_mat_polys,</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;                          <span class="keywordtype">bool</span> decompose_cells = <span class="keyword">true</span>) {</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;  <span class="keywordtype">int</span> nplanes = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(planar_interfaces.size());</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  assert(material_IDs.size() == nplanes + 1);</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;  </div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  <span class="keywordtype">int</span> ncells = mesh.num_owned_cells() + mesh.num_ghost_cells();</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  </div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  <span class="comment">//Get convex MatPoly&#39;s for every cell</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  std::vector&lt; std::vector&lt; Tangram::MatPoly&lt;3&gt; &gt; &gt; cells_polys(ncells);</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  std::vector&lt;int&gt; cur_polys_cellID;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++) {</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <a class="code" href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt;3&gt;</a> mat_poly;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <a class="code" href="namespaceTangram.html#a56993fc630a4a4f0e007615959915181">Tangram::cell_get_matpoly</a>(mesh, icell, &amp;mat_poly);</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <span class="keywordflow">if</span> (decompose_cells) {</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;      mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">facetize_decompose</a>(cells_polys[icell]);</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;      cur_polys_cellID.resize(</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        cur_polys_cellID.size() + cells_polys[icell].size(), icell);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    }</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      cells_polys[icell].push_back(mat_poly);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      cur_polys_cellID.push_back(icell);</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    }</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  }</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  <span class="keywordtype">int</span> ncur_polys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(cur_polys_cellID.size());</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <a class="code" href="structr3d__poly.html">r3d_poly</a>* cur_r3d_polys = <span class="keyword">new</span> <a class="code" href="structr3d__poly.html">r3d_poly</a> [ncur_polys];</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">int</span> POLY_ORDER = 1;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <span class="keywordtype">int</span> nmoments = <a class="code" href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a>(POLY_ORDER);</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  <a class="code" href="r3d_8h.html#aa30ff2c6771668f327e1b0e4bd5cb58f">r3d_real</a> r3d_moments[<a class="code" href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a>(POLY_ORDER)];</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  <span class="keywordtype">int</span> ir3d_poly = 0;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  std::vector&lt; std::vector&lt;double&gt; &gt; cur_polys_moments(ncur_polys);</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++)</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; cells_polys[icell].size(); ipoly++) {</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;      <a class="code" href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">Tangram::matpoly_to_r3dpoly</a>(cells_polys[icell][ipoly], cur_r3d_polys[ir3d_poly]);</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;      <a class="code" href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a>(&amp;cur_r3d_polys[ir3d_poly], r3d_moments, POLY_ORDER);</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      cur_polys_moments[ir3d_poly].resize(nmoments);</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        cur_polys_moments[ir3d_poly][im] += r3d_moments[im];</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;      ir3d_poly++;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    }</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; cells_mat_ids(ncells);</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;  reference_mat_polys.clear();</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  reference_mat_polys.resize(ncells);</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  std::vector&lt; std::vector&lt; std::vector&lt;double&gt; &gt; &gt; cells_mat_moments(ncells);</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iplane = 0; iplane &lt; nplanes; iplane++) {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keywordtype">int</span> cur_mat_id = material_IDs[iplane];</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <a class="code" href="structr3d__plane.html">r3d_plane</a> cur_r3d_plane;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixyz = 0; ixyz &lt; 3; ixyz++)</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;      cur_r3d_plane.<a class="code" href="structr3d__plane.html#a6447f761d2c41d040a0fbdaa8e2885b1">n</a>.<a class="code" href="unionr3d__rvec3.html#ab127c0310533e3caaafcad80b7280fe1">xyz</a>[ixyz] = planar_interfaces[iplane].normal[ixyz];</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    cur_r3d_plane.<a class="code" href="structr3d__plane.html#a82422a38dd2d1975d11d9d0ca6172027">d</a> = planar_interfaces[iplane].dist2origin;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <a class="code" href="structr3d__poly.html">r3d_poly</a>* lower_hs_polys = <span class="keyword">new</span> <a class="code" href="structr3d__poly.html">r3d_poly</a> [ncur_polys];</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    <a class="code" href="structr3d__poly.html">r3d_poly</a>* upper_hs_polys = <span class="keyword">new</span> <a class="code" href="structr3d__poly.html">r3d_poly</a> [ncur_polys];</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <a class="code" href="r3d_8h.html#aad337c9fbabbd571b25490c27f3709d9">r3d_split</a>(cur_r3d_polys, (<a class="code" href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a>) ncur_polys, cur_r3d_plane, </div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;              upper_hs_polys, lower_hs_polys);</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keyword">delete</span> [] cur_r3d_polys;          </div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    std::vector&lt;int&gt; iremaining_polys;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    std::vector&lt; std::vector&lt;double&gt; &gt; remaining_polys_moments;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncur_polys; ipoly++) {</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;      <span class="keywordtype">bool</span> nnz_cutoff = <span class="keyword">false</span>;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;      <span class="keywordflow">if</span> (lower_hs_polys[ipoly].nverts &gt; 0) {</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <a class="code" href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a>(&amp;lower_hs_polys[ipoly], r3d_moments, POLY_ORDER);</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        <span class="keywordflow">if</span> (r3d_moments[0] &gt; std::numeric_limits&lt;double&gt;::epsilon()) {</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;          nnz_cutoff = <span class="keyword">true</span>;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;          <span class="comment">// Poly below the plane is cut off by the plane, add it to </span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;          <span class="comment">// the cell&#39;s list of single-material poly&#39;s</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;          <span class="keywordtype">int</span> icell = cur_polys_cellID[ipoly];</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;          <span class="keywordtype">int</span> cell_mat_id = std::distance(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;            std::find(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;                      cells_mat_ids[icell].end(), cur_mat_id));</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;          <span class="keywordflow">if</span> (cell_mat_id == cells_mat_ids[icell].size()) {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;            cells_mat_ids[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            reference_mat_polys[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            cells_mat_moments[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            cells_mat_moments[icell][cell_mat_id].resize(nmoments, 0.0);</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;            cells_mat_ids[icell][cell_mat_id] = cur_mat_id;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;          }</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;          reference_mat_polys[icell][cell_mat_id].push_back(lower_hs_polys[ipoly]);</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;            cells_mat_moments[icell][cell_mat_id][im] += r3d_moments[im];</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;      }</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;      <span class="keywordflow">if</span> (upper_hs_polys[ipoly].nverts &gt; 0) {</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">if</span> (nnz_cutoff) {</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;            r3d_moments[im] = cur_polys_moments[ipoly][im] - r3d_moments[im];</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        } </div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            r3d_moments[im] = cur_polys_moments[ipoly][im];</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        }</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;        <span class="keywordflow">if</span> (r3d_moments[0] &gt; std::numeric_limits&lt;double&gt;::epsilon()) {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;          <span class="keywordtype">int</span> irpoly = iremaining_polys.size();</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;          iremaining_polys.push_back(ipoly);</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;          remaining_polys_moments.resize(irpoly + 1);</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;          remaining_polys_moments[irpoly].resize(nmoments);</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            remaining_polys_moments[irpoly][im] = r3d_moments[im];</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        }</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;      }</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    }</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keyword">delete</span> [] lower_hs_polys;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    ncur_polys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(iremaining_polys.size());</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <a class="code" href="structr3d__poly.html">r3d_poly</a>* remaining_polys = <span class="keyword">new</span> <a class="code" href="structr3d__poly.html">r3d_poly</a> [ncur_polys];</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    std::vector&lt;int&gt; remaining_polys_cellID(ncur_polys);</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irpoly = 0; irpoly &lt; ncur_polys; irpoly++) {</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;      remaining_polys[irpoly] = upper_hs_polys[iremaining_polys[irpoly]];</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;      remaining_polys_cellID[irpoly] = cur_polys_cellID[iremaining_polys[irpoly]];</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    }</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keyword">delete</span> [] upper_hs_polys;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    cur_r3d_polys = remaining_polys;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    cur_polys_cellID = remaining_polys_cellID;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    cur_polys_moments = remaining_polys_moments;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  }</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="comment">//Poly&#39;s that are left after all planes were processed are also single-material</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  <span class="keywordtype">int</span> cur_mat_id = material_IDs[nplanes];</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncur_polys; ipoly++) {</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keywordtype">int</span> icell = cur_polys_cellID[ipoly];</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="keywordtype">int</span> cell_mat_id = std::distance(cells_mat_ids[icell].begin(),</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;      std::find(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                cells_mat_ids[icell].end(), cur_mat_id));</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    <span class="keywordflow">if</span> (cell_mat_id == cells_mat_ids[icell].size()) {</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      cells_mat_ids[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;      reference_mat_polys[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;      cells_mat_moments[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;      cells_mat_moments[icell][cell_mat_id].resize(nmoments, 0.0);</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;      cells_mat_ids[icell][cell_mat_id] = cur_mat_id;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    }</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    reference_mat_polys[icell][cell_mat_id].push_back(cur_r3d_polys[ipoly]);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;      cells_mat_moments[icell][cell_mat_id][im] += cur_polys_moments[ipoly][im];</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  }</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <span class="keyword">delete</span> [] cur_r3d_polys;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;  cell_num_mats.resize(ncells);</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  cell_mat_ids.clear();</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  cell_mat_volfracs.clear();</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  cell_mat_centroids.clear();</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++) {</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    cell_num_mats[icell] = cells_mat_ids[icell].size();</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    cell_mat_ids.insert(cell_mat_ids.end(), cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                        cells_mat_ids[icell].end());</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    <span class="keywordtype">int</span> offset = cell_mat_volfracs.size();</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    cell_mat_volfracs.resize(offset + cell_num_mats[icell]);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    cell_mat_centroids.resize(offset + cell_num_mats[icell]);</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="keywordtype">double</span> cell_volume = mesh.cell_volume(icell);</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> imat = 0; imat &lt; cell_num_mats[icell]; imat++) {</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;      cell_mat_volfracs[offset + imat] = </div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        cells_mat_moments[icell][imat][0]/cell_volume;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 3; idim++)</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        cell_mat_centroids[offset + imat][idim] = </div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;          cells_mat_moments[icell][imat][idim + 1]/cells_mat_moments[icell][imat][0];</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  }</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;}</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="keyword">template</span> &lt;<span class="keyword">class</span> Mesh_Wrapper&gt;</div><div class="line"><a name="l00248"></a><span class="lineno"><a class="line" href="get__material__moments_8h.html#ad61a0c14d545ed43df9e1ff8426a1d1b">  248</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="get__material__moments_8h.html#ac0c93b6da04bc9fa07409f5af57631ae">get_material_moments</a>(<span class="keyword">const</span> Mesh_Wrapper&amp; mesh,</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                          <span class="keyword">const</span> <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="structTangram_1_1Plane__t.html">Tangram::Plane_t&lt;2&gt;</a> &gt;&amp; linear_interfaces,</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;                          <span class="keyword">const</span> std::vector&lt;int&gt;&amp; material_IDs,</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;                          std::vector&lt;int&gt;&amp; cell_num_mats,</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;                          std::vector&lt;int&gt;&amp; cell_mat_ids,</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                          std::vector&lt;double&gt;&amp; cell_mat_volfracs,</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="classTangram_1_1Point.html">Tangram::Point&lt;2&gt;</a> &gt;&amp; cell_mat_centroids,</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                          <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; <a class="code" href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">std::vector</a>&lt; std::vector&lt;r2d_poly&gt; &gt; &gt;&amp;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;                            reference_mat_polys,</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;                          <span class="keywordtype">bool</span> decompose_cells = <span class="keyword">true</span>) {</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  <span class="keywordtype">int</span> nlines = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(linear_interfaces.size());</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  assert(material_IDs.size() == nlines + 1);</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  </div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <span class="keywordtype">int</span> ncells = mesh.num_owned_cells() + mesh.num_ghost_cells();</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  </div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  <span class="comment">//Get convex MatPoly&#39;s for every cell</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  std::vector&lt; std::vector&lt; Tangram::MatPoly&lt;2&gt; &gt; &gt; cells_polys(ncells);</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;  std::vector&lt;int&gt; cur_polys_cellID;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++) {</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <a class="code" href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt;2&gt;</a> mat_poly;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <a class="code" href="namespaceTangram.html#a56993fc630a4a4f0e007615959915181">Tangram::cell_get_matpoly</a>(mesh, icell, &amp;mat_poly);</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="keywordflow">if</span> (decompose_cells) {</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;      mat_poly.<a class="code" href="classTangram_1_1MatPoly.html#a3a65db5622231e4086244ad25ab6288d">decompose</a>(cells_polys[icell]);</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;      cur_polys_cellID.resize(</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        cur_polys_cellID.size() + cells_polys[icell].size(), icell);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    }</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;    <span class="keywordflow">else</span> {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;      cells_polys[icell].push_back(mat_poly);</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;      cur_polys_cellID.push_back(icell);</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    }</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  }</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <span class="keywordtype">int</span> ncur_polys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(cur_polys_cellID.size());</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <a class="code" href="structr2d__poly.html">r2d_poly</a>* cur_r2d_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">int</span> POLY_ORDER = 1;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="keywordtype">int</span> nmoments = <a class="code" href="r2d_8h.html#abb06105c9ba90a0af19b4a5104c8ccc0">R2D_NUM_MOMENTS</a>(POLY_ORDER);</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  <a class="code" href="r2d_8h.html#a7051e2a3074dcda55d4ffe56a31c910c">r2d_real</a> r2d_moments[<a class="code" href="r2d_8h.html#abb06105c9ba90a0af19b4a5104c8ccc0">R2D_NUM_MOMENTS</a>(POLY_ORDER)];</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  <span class="keywordtype">int</span> ir2d_poly = 0;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;  std::vector&lt; std::vector&lt;double&gt; &gt; cur_polys_moments(ncur_polys);</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++)</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; cells_polys[icell].size(); ipoly++) {</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;      <a class="code" href="namespaceTangram.html#ae282114f99c97df0c59c6006bc065e0b">Tangram::matpoly_to_r2dpoly</a>(cells_polys[icell][ipoly], cur_r2d_polys[ir2d_poly]);</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;      <a class="code" href="r2d_8h.html#a0ca3136f66f864d6bb8dddb2d588c349">r2d_reduce</a>(&amp;cur_r2d_polys[ir2d_poly], r2d_moments, POLY_ORDER);</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;      cur_polys_moments[ir2d_poly].resize(nmoments);</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        cur_polys_moments[ir2d_poly][im] += r2d_moments[im];</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;      ir2d_poly++;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    }</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  std::vector&lt; std::vector&lt;int&gt; &gt; cells_mat_ids(ncells);</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;  reference_mat_polys.clear();</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  reference_mat_polys.resize(ncells);</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;  std::vector&lt; std::vector&lt; std::vector&lt;double&gt; &gt; &gt; cells_mat_moments(ncells);</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> iline = 0; iline &lt; nlines; iline++) {</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;    <span class="keywordtype">int</span> cur_mat_id = material_IDs[iline];</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <a class="code" href="structr2d__plane.html">r2d_plane</a> cur_r2d_plane;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ixy = 0; ixy &lt; 2; ixy++)</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;      cur_r2d_plane.<a class="code" href="structr2d__plane.html#aab3829f60a24bbfe6af8ba1d237e7935">n</a>.<a class="code" href="unionr2d__rvec2.html#ad9a1cfdc5716855be5fff46ff18550e4">xy</a>[ixy] = linear_interfaces[iline].normal[ixy];</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    cur_r2d_plane.<a class="code" href="structr2d__plane.html#a51f453b0f5dc7ec389fc33d46886f0d6">d</a> = linear_interfaces[iline].dist2origin;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    <a class="code" href="structr2d__poly.html">r2d_poly</a>* lower_hp_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;    <a class="code" href="structr2d__poly.html">r2d_poly</a>* upper_hp_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <a class="code" href="r2d_8h.html#a4e28f6b07d5799645b1590201dc20b69">r2d_split</a>(cur_r2d_polys, (<a class="code" href="r2d_8h.html#a40c43d55f6372345f355d5f34eb919c5">r2d_int</a>) ncur_polys, cur_r2d_plane, </div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;              upper_hp_polys, lower_hp_polys);</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="keyword">delete</span> [] cur_r2d_polys;          </div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;    std::vector&lt;int&gt; iremaining_polys;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    std::vector&lt; std::vector&lt;double&gt; &gt; remaining_polys_moments;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncur_polys; ipoly++) {</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;      <span class="keywordtype">bool</span> nnz_cutoff = <span class="keyword">false</span>;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;      <span class="keywordflow">if</span> (lower_hp_polys[ipoly].nverts &gt; 0) {</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        <a class="code" href="r2d_8h.html#a0ca3136f66f864d6bb8dddb2d588c349">r2d_reduce</a>(&amp;lower_hp_polys[ipoly], r2d_moments, POLY_ORDER);</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;        <span class="keywordflow">if</span> (r2d_moments[0] &gt; std::numeric_limits&lt;double&gt;::epsilon()) {</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;          nnz_cutoff = <span class="keyword">true</span>;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;          <span class="comment">// Poly below the line is cut off by the line, add it to </span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;          <span class="comment">// the cell&#39;s list of single-material poly&#39;s</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;          <span class="keywordtype">int</span> icell = cur_polys_cellID[ipoly];</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;          <span class="keywordtype">int</span> cell_mat_id = std::distance(cells_mat_ids[icell].begin(),</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;            std::find(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                      cells_mat_ids[icell].end(), cur_mat_id));</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;          <span class="keywordflow">if</span> (cell_mat_id == cells_mat_ids[icell].size()) {</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            cells_mat_ids[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;            reference_mat_polys[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;            cells_mat_moments[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            cells_mat_moments[icell][cell_mat_id].resize(nmoments, 0.0);</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;            cells_mat_ids[icell][cell_mat_id] = cur_mat_id;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;          }</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;          reference_mat_polys[icell][cell_mat_id].push_back(lower_hp_polys[ipoly]);</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;            cells_mat_moments[icell][cell_mat_id][im] += r2d_moments[im];</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;        }</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;      }</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;      <span class="keywordflow">if</span> (upper_hp_polys[ipoly].nverts &gt; 0) {</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;        <span class="keywordflow">if</span> (nnz_cutoff) {</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;            r2d_moments[im] = cur_polys_moments[ipoly][im] - r2d_moments[im];</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        } </div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        <span class="keywordflow">else</span> {</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            r2d_moments[im] = cur_polys_moments[ipoly][im];</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        }</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        <span class="keywordflow">if</span> (r2d_moments[0] &gt; std::numeric_limits&lt;double&gt;::epsilon()) {</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;          <span class="keywordtype">int</span> irpoly = iremaining_polys.size();</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;          iremaining_polys.push_back(ipoly);</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;          remaining_polys_moments.resize(irpoly + 1);</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;          remaining_polys_moments[irpoly].resize(nmoments);</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;            remaining_polys_moments[irpoly][im] = r2d_moments[im];</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        }</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;      }</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    }</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <span class="keyword">delete</span> [] lower_hp_polys;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    ncur_polys = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(iremaining_polys.size());</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <a class="code" href="structr2d__poly.html">r2d_poly</a>* remaining_polys = <span class="keyword">new</span> <a class="code" href="structr2d__poly.html">r2d_poly</a> [ncur_polys];</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    std::vector&lt;int&gt; remaining_polys_cellID(ncur_polys);</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> irpoly = 0; irpoly &lt; ncur_polys; irpoly++) {</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;      remaining_polys[irpoly] = upper_hp_polys[iremaining_polys[irpoly]];</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;      remaining_polys_cellID[irpoly] = cur_polys_cellID[iremaining_polys[irpoly]];</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    }</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    <span class="keyword">delete</span> [] upper_hp_polys;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    cur_r2d_polys = remaining_polys;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    cur_polys_cellID = remaining_polys_cellID;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    cur_polys_moments = remaining_polys_moments;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;  }</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;  <span class="comment">//Poly&#39;s that are left after all lines were processed are also single-material</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;  <span class="keywordtype">int</span> cur_mat_id = material_IDs[nlines];</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ipoly = 0; ipoly &lt; ncur_polys; ipoly++) {</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="keywordtype">int</span> icell = cur_polys_cellID[ipoly];</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="keywordtype">int</span> cell_mat_id = std::distance(cells_mat_ids[icell].begin(),</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;      std::find(cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                cells_mat_ids[icell].end(), cur_mat_id));</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;    <span class="keywordflow">if</span> (cell_mat_id == cells_mat_ids[icell].size()) {</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;      cells_mat_ids[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;      reference_mat_polys[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;      cells_mat_moments[icell].resize(cell_mat_id + 1);</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;      cells_mat_moments[icell][cell_mat_id].resize(nmoments, 0.0);</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;      cells_mat_ids[icell][cell_mat_id] = cur_mat_id;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    }</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    reference_mat_polys[icell][cell_mat_id].push_back(cur_r2d_polys[ipoly]);</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> im = 0; im &lt; nmoments; im++)</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;      cells_mat_moments[icell][cell_mat_id][im] += cur_polys_moments[ipoly][im];</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;  }</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;  <span class="keyword">delete</span> [] cur_r2d_polys;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;  cell_num_mats.resize(ncells);</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;  cell_mat_ids.clear();</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;  cell_mat_volfracs.clear();</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;  cell_mat_centroids.clear();</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> icell = 0; icell &lt; ncells; icell++) {</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    cell_num_mats[icell] = cells_mat_ids[icell].size();</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;    cell_mat_ids.insert(cell_mat_ids.end(), cells_mat_ids[icell].begin(), </div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;                        cells_mat_ids[icell].end());</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;    <span class="keywordtype">int</span> offset = cell_mat_volfracs.size();</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;    cell_mat_volfracs.resize(offset + cell_num_mats[icell]);</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    cell_mat_centroids.resize(offset + cell_num_mats[icell]);</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;    <span class="keywordtype">double</span> cell_volume = mesh.cell_volume(icell);</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> imat = 0; imat &lt; cell_num_mats[icell]; imat++) {</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;      cell_mat_volfracs[offset + imat] = </div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        cells_mat_moments[icell][imat][0]/cell_volume;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> idim = 0; idim &lt; 2; idim++)</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        cell_mat_centroids[offset + imat][idim] = </div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;          cells_mat_moments[icell][imat][idim + 1]/cells_mat_moments[icell][imat][0];</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;    }</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;  }</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;}</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="preprocessor">#endif</span></div><div class="ttc" id="r3d_8h_html_ae591f11a646bffc0b497ba6d440f326a"><div class="ttname"><a href="r3d_8h.html#ae591f11a646bffc0b497ba6d440f326a">r3d_reduce</a></div><div class="ttdeci">void r3d_reduce(r3d_poly *poly, r3d_real *moments, r3d_int polyorder)</div></div>
<div class="ttc" id="structr3d__plane_html_a82422a38dd2d1975d11d9d0ca6172027"><div class="ttname"><a href="structr3d__plane.html#a82422a38dd2d1975d11d9d0ca6172027">r3d_plane::d</a></div><div class="ttdeci">r3d_real d</div><div class="ttdef"><b>Definition:</b> r3d.h:79</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a3a65db5622231e4086244ad25ab6288d"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a3a65db5622231e4086244ad25ab6288d">Tangram::MatPoly::decompose</a></div><div class="ttdeci">void decompose(std::vector&lt; MatPoly&lt; D &gt; &gt; &amp;sub_polys) const</div><div class="ttdoc">Decomposes this MatPoly into MatPoly&amp;#39;s using its centroid. If faces of MatPoly are planar...</div></div>
<div class="ttc" id="namespaceTangram_html_a56993fc630a4a4f0e007615959915181"><div class="ttname"><a href="namespaceTangram.html#a56993fc630a4a4f0e007615959915181">Tangram::cell_get_matpoly</a></div><div class="ttdeci">void cell_get_matpoly(const Mesh_Wrapper &amp;Mesh, int const cellid, MatPoly&lt; 2 &gt; *mat_poly)</div><div class="ttdef"><b>Definition:</b> MatPoly.h:684</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html_a8e814a40956aee6c5ade0c20abefe920"><div class="ttname"><a href="classTangram_1_1MatPoly.html#a8e814a40956aee6c5ade0c20abefe920">Tangram::MatPoly::facetize_decompose</a></div><div class="ttdeci">void facetize_decompose(std::vector&lt; MatPoly&lt; D &gt; &gt; &amp;sub_polys) const</div><div class="ttdoc">Facetizes and decomposes this MatPoly into simplex MatPoly&amp;#39;s using its centroid. </div></div>
<div class="ttc" id="structr3d__plane_html_a6447f761d2c41d040a0fbdaa8e2885b1"><div class="ttname"><a href="structr3d__plane.html#a6447f761d2c41d040a0fbdaa8e2885b1">r3d_plane::n</a></div><div class="ttdeci">r3d_rvec3 n</div><div class="ttdef"><b>Definition:</b> r3d.h:78</div></div>
<div class="ttc" id="structr2d__plane_html_aab3829f60a24bbfe6af8ba1d237e7935"><div class="ttname"><a href="structr2d__plane.html#aab3829f60a24bbfe6af8ba1d237e7935">r2d_plane::n</a></div><div class="ttdeci">r2d_rvec2 n</div><div class="ttdef"><b>Definition:</b> r2d.h:81</div></div>
<div class="ttc" id="r3d_8h_html_a3aa887a1c16c46e933b08d25625aa024"><div class="ttname"><a href="r3d_8h.html#a3aa887a1c16c46e933b08d25625aa024">r3d_int</a></div><div class="ttdeci">int32_t r3d_int</div><div class="ttdoc">Integer types used for indexing. </div><div class="ttdef"><b>Definition:</b> r3d.h:47</div></div>
<div class="ttc" id="r2d_8h_html_a7051e2a3074dcda55d4ffe56a31c910c"><div class="ttname"><a href="r2d_8h.html#a7051e2a3074dcda55d4ffe56a31c910c">r2d_real</a></div><div class="ttdeci">double r2d_real</div><div class="ttdoc">Real type specifying the precision to be used in calculations. </div><div class="ttdef"><b>Definition:</b> r2d.h:46</div></div>
<div class="ttc" id="structr2d__poly_html"><div class="ttname"><a href="structr2d__poly.html">r2d_poly</a></div><div class="ttdoc">A polygon. Can be convex, nonconvex, even multiply-connected. </div><div class="ttdef"><b>Definition:</b> r2d.h:96</div></div>
<div class="ttc" id="r3d_8h_html_aa30ff2c6771668f327e1b0e4bd5cb58f"><div class="ttname"><a href="r3d_8h.html#aa30ff2c6771668f327e1b0e4bd5cb58f">r3d_real</a></div><div class="ttdeci">double r3d_real</div><div class="ttdoc">Real type specifying the precision to be used in calculations. </div><div class="ttdef"><b>Definition:</b> r3d.h:41</div></div>
<div class="ttc" id="unionr2d__rvec2_html_ad9a1cfdc5716855be5fff46ff18550e4"><div class="ttname"><a href="unionr2d__rvec2.html#ad9a1cfdc5716855be5fff46ff18550e4">r2d_rvec2::xy</a></div><div class="ttdeci">r2d_real xy[2]</div><div class="ttdef"><b>Definition:</b> r2d.h:63</div></div>
<div class="ttc" id="classTangram_1_1MatPoly_html"><div class="ttname"><a href="classTangram_1_1MatPoly.html">Tangram::MatPoly&lt; 3 &gt;</a></div></div>
<div class="ttc" id="structr2d__plane_html_a51f453b0f5dc7ec389fc33d46886f0d6"><div class="ttname"><a href="structr2d__plane.html#a51f453b0f5dc7ec389fc33d46886f0d6">r2d_plane::d</a></div><div class="ttdeci">r2d_real d</div><div class="ttdef"><b>Definition:</b> r2d.h:82</div></div>
<div class="ttc" id="namespaceTangram_html_a2364ea47380698d6b380574978c068da"><div class="ttname"><a href="namespaceTangram.html#a2364ea47380698d6b380574978c068da">Tangram::matpoly_to_r3dpoly</a></div><div class="ttdeci">void matpoly_to_r3dpoly(const MatPoly&lt; 3 &gt; &amp;mat_poly, r3d_poly &amp;r3dpoly)</div><div class="ttdoc">Converts a MatPoly to a polyhedron in R3D format. </div><div class="ttdef"><b>Definition:</b> split_r3d.h:42</div></div>
<div class="ttc" id="classTangram_1_1Point_html"><div class="ttname"><a href="classTangram_1_1Point.html">Tangram::Point</a></div><div class="ttdoc">Represents a point in an N-dimensional space. </div><div class="ttdef"><b>Definition:</b> Point.h:48</div></div>
<div class="ttc" id="namespaceTangram_html_ae282114f99c97df0c59c6006bc065e0b"><div class="ttname"><a href="namespaceTangram.html#ae282114f99c97df0c59c6006bc065e0b">Tangram::matpoly_to_r2dpoly</a></div><div class="ttdeci">void matpoly_to_r2dpoly(const MatPoly&lt; 2 &gt; &amp;mat_poly, r2d_poly &amp;r2dpoly)</div><div class="ttdoc">Converts a MatPoly to a polygon in R2D format. </div><div class="ttdef"><b>Definition:</b> split_r2d.h:84</div></div>
<div class="ttc" id="split__r2d_8h_html"><div class="ttname"><a href="split__r2d_8h.html">split_r2d.h</a></div><div class="ttdoc">Routines for splitting convex or non-convex MatPoly&amp;#39;s by a cutting plane. Uses R2D. A convex MatPoly will be split into two MatPoly&amp;#39;s. A non-convex MatPoly will be decomposed into convex polyhedra using its centroid, several MatPoly&amp;#39;s could be returned for each half-plane. All the faces of the input MatPoly are assumed to be planar and no additional facetization is performed, so when sequentially splitting of a faceted MatPoly, no additional facets will be introduced. </div></div>
<div class="ttc" id="get__material__moments_8h_html_ac0c93b6da04bc9fa07409f5af57631ae"><div class="ttname"><a href="get__material__moments_8h.html#ac0c93b6da04bc9fa07409f5af57631ae">get_material_moments</a></div><div class="ttdeci">void get_material_moments(const Mesh_Wrapper &amp;mesh, const std::vector&lt; Tangram::Plane_t&lt; 3 &gt; &gt; &amp;planar_interfaces, const std::vector&lt; int &gt; &amp;material_IDs, std::vector&lt; int &gt; &amp;cell_num_mats, std::vector&lt; int &gt; &amp;cell_mat_ids, std::vector&lt; double &gt; &amp;cell_mat_volfracs, std::vector&lt; Tangram::Point&lt; 3 &gt; &gt; &amp;cell_mat_centroids, std::vector&lt; std::vector&lt; std::vector&lt; r3d_poly &gt; &gt; &gt; &amp;reference_mat_polys, bool decompose_cells=true)</div><div class="ttdoc">For a given mesh and a sequence of planes computes volume fractions and centroids. r3d is used to compute intersection moments. For every plane in the sequence, the remaining parts of the domain in the lower half-space are assigned the corresponding material and excluded from further consideration. </div><div class="ttdef"><b>Definition:</b> get_material_moments.h:40</div></div>
<div class="ttc" id="tangram_8h_html"><div class="ttname"><a href="tangram_8h.html">tangram.h</a></div></div>
<div class="ttc" id="r2d_8h_html_a0ca3136f66f864d6bb8dddb2d588c349"><div class="ttname"><a href="r2d_8h.html#a0ca3136f66f864d6bb8dddb2d588c349">r2d_reduce</a></div><div class="ttdeci">void r2d_reduce(r2d_poly *poly, r2d_real *moments, r2d_int polyorder)</div></div>
<div class="ttc" id="structTangram_1_1Plane__t_html"><div class="ttname"><a href="structTangram_1_1Plane__t.html">Tangram::Plane_t&lt; 3 &gt;</a></div></div>
<div class="ttc" id="structr3d__plane_html"><div class="ttname"><a href="structr3d__plane.html">r3d_plane</a></div><div class="ttdef"><b>Definition:</b> r3d.h:76</div></div>
<div class="ttc" id="structr2d__plane_html"><div class="ttname"><a href="structr2d__plane.html">r2d_plane</a></div><div class="ttdoc">A plane. </div><div class="ttdef"><b>Definition:</b> r2d.h:80</div></div>
<div class="ttc" id="r2d_8h_html_a4e28f6b07d5799645b1590201dc20b69"><div class="ttname"><a href="r2d_8h.html#a4e28f6b07d5799645b1590201dc20b69">r2d_split</a></div><div class="ttdeci">void r2d_split(r2d_poly *inpolys, r2d_int npolys, r2d_plane plane, r2d_poly *out_pos, r2d_poly *out_neg)</div><div class="ttdoc">Splits a list of polygons across a single plane. </div></div>
<div class="ttc" id="structr3d__poly_html"><div class="ttname"><a href="structr3d__poly.html">r3d_poly</a></div><div class="ttdef"><b>Definition:</b> r3d.h:93</div></div>
<div class="ttc" id="r2d_8h_html_a40c43d55f6372345f355d5f34eb919c5"><div class="ttname"><a href="r2d_8h.html#a40c43d55f6372345f355d5f34eb919c5">r2d_int</a></div><div class="ttdeci">int32_t r2d_int</div><div class="ttdoc">Integer types used for indexing. </div><div class="ttdef"><b>Definition:</b> r2d.h:52</div></div>
<div class="ttc" id="unionr3d__rvec3_html_ab127c0310533e3caaafcad80b7280fe1"><div class="ttname"><a href="unionr3d__rvec3.html#ab127c0310533e3caaafcad80b7280fe1">r3d_rvec3::xyz</a></div><div class="ttdeci">r3d_real xyz[3]</div><div class="ttdef"><b>Definition:</b> r3d.h:59</div></div>
<div class="ttc" id="r3d_8h_html_ace7c6f2c67e44a0a24c13f4cd1dbf138"><div class="ttname"><a href="r3d_8h.html#ace7c6f2c67e44a0a24c13f4cd1dbf138">R3D_NUM_MOMENTS</a></div><div class="ttdeci">#define R3D_NUM_MOMENTS(order)</div><div class="ttdoc">Integrate a polynomial density over a polyhedron using simplicial decomposition. Uses the fast recurs...</div><div class="ttdef"><b>Definition:</b> r3d.h:154</div></div>
<div class="ttc" id="r2d_8h_html_abb06105c9ba90a0af19b4a5104c8ccc0"><div class="ttname"><a href="r2d_8h.html#abb06105c9ba90a0af19b4a5104c8ccc0">R2D_NUM_MOMENTS</a></div><div class="ttdeci">#define R2D_NUM_MOMENTS(order)</div><div class="ttdoc">Integrate a polynomial density over a polygon using simplicial decomposition. Uses the fast recursive...</div><div class="ttdef"><b>Definition:</b> r2d.h:160</div></div>
<div class="ttc" id="r3d_8h_html_aad337c9fbabbd571b25490c27f3709d9"><div class="ttname"><a href="r3d_8h.html#aad337c9fbabbd571b25490c27f3709d9">r3d_split</a></div><div class="ttdeci">void r3d_split(r3d_poly *inpolys, r3d_int npolys, r3d_plane plane, r3d_poly *out_pos, r3d_poly *out_neg)</div><div class="ttdoc">Splits a list of polyhedra across a single plane. </div></div>
<div class="ttc" id="namespaceTangram_html_a71c39deca72d48990415ee231a9170b1"><div class="ttname"><a href="namespaceTangram.html#a71c39deca72d48990415ee231a9170b1">Tangram::vector</a></div><div class="ttdeci">std::vector&lt; T &gt; vector</div><div class="ttdef"><b>Definition:</b> tangram.h:137</div></div>
<div class="ttc" id="split__r3d_8h_html"><div class="ttname"><a href="split__r3d_8h.html">split_r3d.h</a></div><div class="ttdoc">Routines for splitting convex or non-convex MatPoly&amp;#39;s by a cutting plane. Uses R3D. A convex MatPoly will be split into two MatPoly&amp;#39;s. A non-convex MatPoly will be decomposed into convex polyhedra using its centroid, several MatPoly&amp;#39;s could be returned for each half-plane. All the faces of the input MatPoly are assumed to be planar and no additional facetization is performed, so when sequentially splitting of a faceted MatPoly, no additional facets will be introduced. </div></div>
</div><!-- fragment --></div><!-- contents -->
<!--
This file is part of the Ristra tangram project.
Please see the license file at the root of this repository, or at:
https://github.com/laristra/tangram/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2017
	<a href="http://lanl.gov"> Triad National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/tangram/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-17-133
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:portage@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/tangram">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
</body>
</html>
